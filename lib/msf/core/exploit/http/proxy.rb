# -*- coding: binary -*-
require 'rex/service_manager'
require 'rex/proto/proxy/http'
require 'msf/core/exploit/http/server'

###
# This module provides an HTTP proxy server
# By default the proxy functions in MITM mode
# forwarding all requests along the switchboard.
# Settings RHOST, RPORT, and VHOST will restrict
# the proxy conenctions to those settings making
# it an "http-connect" proxy.
##

module Msf
module Exploit::Remote::HttpServer::Proxy

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer

  def initialize(info = {})
    super(
      'Actions'     =>
        [
          [ 'WebServer' ]
        ],
      'PassiveActions' =>
        [
          'WebServer'
        ],
      'DefaultAction'  => 'WebServer'
    )

    # We handle these differently depending on how we use the proxy
    deregister_options('RHOST', 'RPORT')
    register_options(
      [
        OptString.new('RHOST', [ false, "Set this to direct all traffic to a specific host"]),
        OptInt.new('RPORT', [ false, "Set this in conjunction with RHOST to direct all traffic to specific port"]),
        OptBool.new('RSSL', [false, "Force all outbound connections to use SSL"]),
        OptString.new('URIPATH', [ true,  "The base URI at which the proxy will begin to forward requests", '/'])
      ], Exploit::Remote::HttpServer::Proxy
    )
    # register_advanced_options(
    #   [   
    #     OptBool.new('HTTP::proxy::strip_proxy_headers', [true, 'Remove proxy-specific headers from client', true]),
    #     OptString.new('HTTP::proxy::strip_headers', [
    #       false, 'Additional headers to remove from requests',
    #       'Connection Proxy-Connection Content-Length Host'
    #     ]),
    #   ], Exploit::Remote::HttpServer::Proxy
    # )   

  end

  def start_service(opts = {})

    check_dependencies

    comm = datastore['ListenerComm']
    if (comm.to_s == "local")
      comm = ::Rex::Socket::Comm::Local
    else
      comm = nil
    end

    # Default the server host and port to what is required by the mixin.
    opts = {
      'ServerHost' => datastore['SRVHOST'],
      'ServerPort' => datastore['SRVPORT'].to_i,
      'Comm'       => comm
    }.update(opts)

    # Configure remote target variables
    # rport = datastore['RPORT'].nil? or datastore['RPORT'].to_i == 0 ? nil : datastore['RPORT']
    # rssl = datastore['RSSL'] ? datastore['RSSL'] : nil
    # Start a new HTTP server service.
    self.service = Rex::ServiceManager.start(
      Rex::Proto::Proxy::Http,
      opts['ServerPort'],
      opts['ServerHost'],
      datastore['SSL'],
      {
        'Msf'        => framework,
        'MsfExploit' => self,
      },
      opts['Comm'],
      datastore['SSLCert'],
      datastore['Proxies'],
      datastore['RHOST'],
      datastore['RPORT'],
      datastore['RSSL']
    )

    # Configure service parameters outside of initializer
    self.service.server_name = datastore['HTTP::server_name']
    # self.service.strip_proxy_headers = datastore['HTTP::proxy::strip_proxy_headers']
    # self.service.strip_headers = datastore['HTTP::proxy::strip_headers'].split(/,|\s/)

    # Add request and response hooks
    service.on_http_connect_proc = Proc.new { |cli,request|
      proxy_action_connect(cli,request)
    }

    service.on_http_request_proc = Proc.new { |cli,request|
      proxy_action_request(cli,request)
    }

    service.on_http_response_proc = Proc.new { |cli,response|
      proxy_action_response(cli,response)
    }

    proto = (datastore["SSL"] ? "https" : "http")

    vprint_status("Using URL: #{proto}://#{opts['ServerHost']}:#{opts['ServerPort']}/")

    if (opts['ServerHost'] == '0.0.0.0')
      print_status(" Local IP: #{proto}://#{Rex::Socket.source_address('1.2.3.4')}:#{opts['ServerPort']}/")
    end

  end

  # Overload this to work wtih connect request
  def proxy_action_connect(cli, request)
    true # MITM or logging can go here
  end

  # Overload this to work wtih initial request
  def proxy_action_request(cli, request)
    true # MITM or logging can go here
  end

  # Overload this to work with response
  def proxy_action_response(cli, response)
    true
  end

end

end
